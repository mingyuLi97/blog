import{_ as s,o as a,c as l,R as e}from"./chunks/framework.35669211.js";const u=JSON.parse('{"title":"模版解析","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/vue/templateCompiler.md"}'),n={name:"knowledge/vue/templateCompiler.md"},t=e(`<h1 id="模版解析" tabindex="-1">模版解析 <a class="header-anchor" href="#模版解析" aria-label="Permalink to &quot;模版解析&quot;">​</a></h1><p>Vue 模版解析就是将开发者输入的模版字符串转换成 render 函数。此过程分为三个阶段</p><ol><li>解析字符串生成虚拟 DOM</li><li>执行编译优化，递归遍历 AST，标记静态节点和静态根节点</li><li>生成 render 函数</li></ol><h2 id="总流程" tabindex="-1">总流程 <a class="header-anchor" href="#总流程" aria-label="Permalink to &quot;总流程&quot;">​</a></h2><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202301201428179.png" alt="总流程" data-__preview__="true"></p><h2 id="解析器" tabindex="-1">解析器 <a class="header-anchor" href="#解析器" aria-label="Permalink to &quot;解析器&quot;">​</a></h2><h4 id="html-解析器" tabindex="-1">HTML 解析器 <a class="header-anchor" href="#html-解析器" aria-label="Permalink to &quot;HTML 解析器&quot;">​</a></h4><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 伪代码</span></span>
<span class="line"><span style="color:#61AFEF;">parseHTML</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">, {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">start</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">tag</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">attrs</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">unary</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 每当解析到标签的开始位置时，触发该函数</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">end</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 每当解析到标签的结束位置时，触发该函数</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">chars</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">text</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 每当解析到文本时，触发该函数</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">comment</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">text</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 每当解析到注释时，触发该函数</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span></code></pre></div><ol><li>接收到模版字符串</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E06C75;">tpl</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">\`&lt;div&gt;</span></span>
<span class="line"><span style="color:#98C379;">    &lt;h1&gt;我是Berwin&lt;/h1&gt;</span></span>
<span class="line"><span style="color:#98C379;">    &lt;p&gt;我今年23岁&lt;/p&gt;</span></span>
<span class="line"><span style="color:#98C379;">&lt;/div&gt;\`</span><span style="color:#ABB2BF;">;</span></span></code></pre></div><ol start="2"><li><p>通过正则表达式匹配标签（开始标签、结束标签、文本标签等），调用对应的钩子函数（start、end、chars）</p><ul><li>开始标签中匹配出对应的属性值，拿到这些属性构建虚拟节点</li><li>匹配到开始标签，将节点入栈（当前栈顶的节点就是该节点的父亲）</li><li>匹配到结束标签，将栈顶的节点出栈</li></ul></li><li><p>删除匹配到的标签</p></li></ol><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202301191644945.png" alt="模板解析成AST" data-__preview__="true"></p><h2 id="优化器" tabindex="-1">优化器 <a class="header-anchor" href="#优化器" aria-label="Permalink to &quot;优化器&quot;">​</a></h2><p>对一些静态的节点（更新时 DOM 不会变化的节点）打标记。</p><h3 id="好处" tabindex="-1">好处： <a class="header-anchor" href="#好处" aria-label="Permalink to &quot;好处：&quot;">​</a></h3><ul><li>使 DIFF 的过程中可以跳过，既节省了 JS 运算成本，又减少了 DOM 的操作。</li><li>每次重新渲染的时候，静态节点可以直接复用，不用重新生成</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>每次重新渲染，都会使用最新的状态生成一份全新的 VNode 与旧的 VNode 进行对比。而在生成 vode 的过程中，如果发现一个节点被标记为静态节点，那么除了首次渲染会生成节点外，在重新渲染时并不会生成新的子节点，而是克隆已经存在的静态节点。</p></div><h3 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h3><p><a href="https://github1s.com/vuejs/vue/blob/2.6/src/compiler/optimizer.js#L21-L22" target="_blank" rel="noreferrer">源码实现</a></p><p><strong>1. 标记静态节点</strong></p><p>递归遍历 AST，根据 <a href="https://github1s.com/vuejs/vue/blob/2.6/src/compiler/optimizer.js#L100-L101" target="_blank" rel="noreferrer"><code>isStatic()</code></a>, 在当前节点上增加 <code>static</code> 属性</p><p>HTML 解析器在调用钩子函数创建 AST 节点时会根据节点类型的不同为节点加上不同的 type 属性，来标记 AST 节点的节点类型。所以在判断一个节点是否为静态节点时首先会根据 type 值判断节点类型。</p><ul><li><code>type: 2</code><ul><li>包含变量的动态文本节点，=&gt; <code>false</code></li><li>仅纯文本节点 =&gt; <code>true</code></li></ul></li><li><code>type: 1</code> 说明该节点是元素节点 <ul><li>使用了 v-pre 指令，那就断定它是静态节点；</li><li>没有使用 v-pre 指令，那它要成为静态节点必须满足： <ul><li>不能使用动态绑定语法，即标签上不能有 v-、@、:开头的属性；</li><li>不能使用 v-if、v-else、v-for 指令；</li><li>不能是内置组件，即标签名不能是 slot 和 component；</li><li>标签名必须是平台保留标签，即不能是组件；</li><li>当前节点的父节点不能是带有  v-for  的  template  标签；</li><li>节点的所有属性的  key  都必须是静态节点才有的  key，注：静态节点的 key 是有限的，它只能是 type,tag,attrsList,attrsMap,plain,parent,children,attrs 之一。</li></ul></li></ul></li></ul><p><strong>2. 标记静态根节点</strong> 递归遍历 AST，根据子节点类型判断，在当前节点标记 <code>staticRoot</code></p><ul><li>节点本身必须是静态节点</li><li>必须拥有子节点 children</li><li>子节点不能只是只有一个文本节点</li></ul><h2 id="生成器" tabindex="-1">生成器 <a class="header-anchor" href="#生成器" aria-label="Permalink to &quot;生成器&quot;">​</a></h2><p>根据生成的 AST 拼接成对应的 render 函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">with</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">_c</span><span style="color:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#98C379;">&#39;div&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">    {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#E06C75;">attrs</span><span style="color:#ABB2BF;">: { </span><span style="color:#E06C75;">id</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;el&#39;</span><span style="color:#ABB2BF;"> }</span></span>
<span class="line"><span style="color:#ABB2BF;">    }[(</span><span style="color:#61AFEF;">_c</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;p&#39;</span><span style="color:#ABB2BF;">), [</span><span style="color:#61AFEF;">_v</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;Hello &#39;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">_s</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">name</span><span style="color:#ABB2BF;">))])]</span></span>
<span class="line"><span style="color:#ABB2BF;">  );</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre></div><h2 id="为什么使用-with-语句" tabindex="-1">为什么使用 with 语句？ <a class="header-anchor" href="#为什么使用-with-语句" aria-label="Permalink to &quot;为什么使用 with 语句？&quot;">​</a></h2><p>vue 并没有对模板中的 javascript 表达式进行 ast 语法分析，如果要移除 <code>with</code>，就需要对 javascript 表达式进行 ast 语法分析，并且还需要一个专门的解释器对 ast 语法树进行解释，这样就会导致存在两个并行的解析器，这样维护成本高，还可能会有潜在的 bug 风险。</p><h2 id="template-和-render-函数的区别" tabindex="-1">template 和 render 函数的区别 <a class="header-anchor" href="#template-和-render-函数的区别" aria-label="Permalink to &quot;template 和 render 函数的区别&quot;">​</a></h2><p>Vue 支持 template 模版和 render 函数两种渲染方式， 如果同时使用两者，会优先采用 render 的方式。 本质上，模版最终也会编译成 render 函数。 模版的写法更贴近于 html，因此其看起来很直观，render 函数本身是 js，因此更灵活。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vue 分为完整版（vue.min.js）和运行时（vue.runtime.min.js）两个版本</p><ul><li>完整版内置了 complier，因此可以在运行时处理 template 语法，但是其包体积较大。</li><li>运行时仅支持 render 函数，是官方默认的版本。（一般情况下模版编译是在项目本地打包的时候处理）。</li></ul></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://cnodejs.org/topic/5caae462d68ff5064921ae7e" target="_blank" rel="noreferrer">深入浅出 Vue.js</a></li><li><a href="https://github.com/berwin/Blog/issues/18" target="_blank" rel="noreferrer">https://github.com/berwin/Blog/issues/18</a></li><li><a href="https://juejin.cn/post/7166831346319360036#heading-3" target="_blank" rel="noreferrer">掘金：【vue2 深度学习】模板编译篇-优化器</a></li><li><a href="https://segmentfault.com/q/1010000018552495" target="_blank" rel="noreferrer">https://segmentfault.com/q/1010000018552495</a></li></ul>`,35),o=[t];function p(r,c,i,B,d,y){return a(),l("div",null,o)}const F=s(n,[["render",p]]);export{u as __pageData,F as default};
