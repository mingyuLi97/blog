import{_ as a,o as s,c as l,R as o}from"./chunks/framework.35669211.js";const h=JSON.parse('{"title":"jsbridge","description":"","frontmatter":{},"headers":[],"relativePath":"engineer/hybrid/jsb.md"}'),e={name:"engineer/hybrid/jsb.md"},n=o(`<h1 id="jsbridge" tabindex="-1">jsbridge <a class="header-anchor" href="#jsbridge" aria-label="Permalink to &quot;jsbridge&quot;">​</a></h1><p>用途：构建 Native 和 js 之间的消息通道，实现双向通信。</p><h2 id="js-调用-native" tabindex="-1">js 调用 Native <a class="header-anchor" href="#js-调用-native" aria-label="Permalink to &quot;js 调用 Native&quot;">​</a></h2><h3 id="_1-拦截-url-scheme" tabindex="-1">1. 拦截 <strong>URL_SCHEME</strong> <a class="header-anchor" href="#_1-拦截-url-scheme" aria-label="Permalink to &quot;1. 拦截 **URL_SCHEME**&quot;">​</a></h3><p><code>URL Scheme</code> 是类 URL 的一种请求格式：<code>&lt;protocol&gt;://&lt;host&gt;/&lt;path&gt;?&lt;query&gt;#fragment</code></p><p>一般会约定一种协议格式，例：<code>weixin://dl/about</code></p><ul><li>如果符合我们自定义的 URL Schema，对 URL 进行解析，拿到相关操作、操作，进而调用原生 Native 的方法</li><li>如果不符合我们自定义的 URL Schema，我们直接转发，请求真正的服务</li></ul><div class="tip custom-block"><p class="custom-block-title">Web 发送 URL 请求的方法</p><ul><li><code>使用 iframe.src (常用)</code></li><li>a 标签 (需要用户操作)</li><li>location.href (能会引起页面的跳转丢失调用)</li><li>发送 ajax 请求 (Android 没有相应的拦截方法)</li></ul></div><h4 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：兼容性好</p><p>缺点：</p><ul><li>延时高</li><li>URL scheme 长度有限，内容过多可能会丢失字符；</li><li>不支持同步返回结果，所有信息传送都需要调用 iframe 请求，使用 callback 得到返回的数据。</li></ul><h3 id="_2-方法拦截" tabindex="-1">2. 方法拦截 <a class="header-anchor" href="#_2-方法拦截" aria-label="Permalink to &quot;2. 方法拦截&quot;">​</a></h3><blockquote><p>该方法的实现方式和 URL_SCHEME 相似，都是通过对 WebView 信息冒泡传递的拦截，从而达到通讯</p></blockquote><p>WebView 中的 prompt/console/alert 拦截，通常使用 prompt ，因为这个方法在前端中使用频率低，比较不会出现冲突</p><h3 id="_3-注入-api" tabindex="-1">3. 注入 API <a class="header-anchor" href="#_3-注入-api" aria-label="Permalink to &quot;3. 注入 API&quot;">​</a></h3><p>这个方法会通过 webView 提供的接口，App 将 Native 的相关接口注入到 JS 的 Context（window）的对象中，一般来说这个对象内的方法名与 Native 相关方法名是相同的，Web 端就可以直接在全局 window 下使用这个暴露的全局 JS 对象，进而调用原生端的方法。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">window</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">WeixinJSBridge</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">showDialog</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;hello&#39;</span><span style="color:#ABB2BF;">);</span></span></code></pre></div><h4 id="如何实现回调" tabindex="-1">如何实现回调 <a class="header-anchor" href="#如何实现回调" aria-label="Permalink to &quot;如何实现回调&quot;">​</a></h4><p>通过两次单项通信实现：一端调用的时候在参数中加一个 callbackId 标记对应的回调，对端接收到调用请求后，进行实际操作，如果带有 callbackId，对端再进行一次调用，将结果、callbackId 回传回来，这端根据 callbackId 匹配相应的回调，将结果传入执行就可以了。</p><h4 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><p>优点：通信时间短，调用方便</p><p>缺点：低版本不友好</p><h2 id="native-调用-js" tabindex="-1">Native 调用 js <a class="header-anchor" href="#native-调用-js" aria-label="Permalink to &quot;Native 调用 js&quot;">​</a></h2><p>js 是解释型语言，其特点就是能随时随地执行一段 js 代码 。 Android 4.4 之前只能用 <code>loadUrl</code> 来实现，并且无法执行回调：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">String</span><span style="color:#E06C75;"> jsCode </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">format</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;window.showWebDialog(&#39;%s&#39;)&quot;</span><span style="color:#ABB2BF;">, text);</span></span>
<span class="line"><span style="color:#E5C07B;">webView</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">loadUrl</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;javascript: &quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> jsCode);</span></span></code></pre></div><p>Android 4.4 之后提供了 <code>evaluateJavascript</code> 来执行 JS 代码，并且可以获取返回值执行回调：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">String</span><span style="color:#E06C75;"> jsCode </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">format</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;window.showWebDialog(&#39;%s&#39;)&quot;</span><span style="color:#ABB2BF;">, text);</span></span>
<span class="line"><span style="color:#E5C07B;">webView</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">evaluateJavascript</span><span style="color:#ABB2BF;">(jsCode, </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">ValueCallback</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">&gt;() {</span></span>
<span class="line"><span style="color:#ABB2BF;">@</span><span style="color:#E5C07B;">Override</span></span>
<span class="line"><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> </span><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> onReceiveValue</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">value</span><span style="color:#ABB2BF;">)</span><span style="color:#61AFEF;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span></code></pre></div><p>iOS 的 UIWebView 使用 <code>stringByEvaluatingJavaScriptFromString：</code></p><div class="language-objective-c"><button title="Copy Code" class="copy"></button><span class="lang">objective-c</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">NSString</span><span style="color:#ABB2BF;"> _jsStr </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">@&quot;执行的 JS 代码&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">[webView </span><span style="color:#61AFEF;">stringByEvaluatingJavaScriptFromString:</span><span style="color:#ABB2BF;">jsStr];</span></span></code></pre></div><p>iOS 的 WKWebView 使用 <code>evaluateJavaScript：</code></p><div class="language-objective-c"><button title="Copy Code" class="copy"></button><span class="lang">objective-c</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">[webView </span><span style="color:#61AFEF;">evaluateJavaScript:</span><span style="color:#98C379;">@&quot;执行的 JS 代码&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">completionHandler:</span><span style="color:#ABB2BF;">^(</span><span style="color:#C678DD;">id</span><span style="color:#ABB2BF;"> \\_Nullable response, </span><span style="color:#E5C07B;">NSError</span><span style="color:#ABB2BF;"> \\_ \\_Nullable error) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}];</span></span></code></pre></div>`,32),p=[n];function t(c,r,i,B,d,y){return s(),l("div",null,p)}const b=a(e,[["render",t]]);export{h as __pageData,b as default};
