import{_ as e,o as a,c as i,Q as o}from"./chunks/framework.fa80b722.js";const f=JSON.parse('{"title":"概念","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/vue/basic.md","filePath":"knowledge/vue/basic.md"}'),t={name:"knowledge/vue/basic.md"},r=o('<h1 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h1><h2 id="对-mvvm-的理解" tabindex="-1">对 MVVM 的理解 <a class="header-anchor" href="#对-mvvm-的理解" aria-label="Permalink to &quot;对 MVVM 的理解&quot;">​</a></h2><p>MVVM 有三个组成部分</p><ul><li>Model（模型）：主要指数据和逻辑</li><li>View（视图）：屏幕上展示的 UI</li><li>ViewModel（绑定器）：绑定在视图和模型中间进行通信</li></ul><p>Model 和 View 之间是不允许直接通信的，ViewModel 是双向通信的 可以将 Model 的更改同步到 View，也可以将 View 的更改同步到 Model。</p><p>解决了 Model 和 View 耦合的问题 还同时解决了维护两者映射关系的大量繁杂代码和 DOM 操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。</p><p>Vue 借助了 MVVM 的设计思想，其内部通过 <strong>数据绑定</strong> 和 <strong>DOM 事件监听</strong> 实现了双向绑定，典型的是 <code>v-model</code> 的实现。但是提供了 <code>$refs</code> 属性 使模型可以直接操作视图，所以 Vue 是不完全的 MVVM</p><h2 id="vue-和-react-看法" tabindex="-1">Vue 和 React 看法 <a class="header-anchor" href="#vue-和-react-看法" aria-label="Permalink to &quot;Vue 和 React 看法&quot;">​</a></h2><h3 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h3><ol><li>组件化开发</li><li>MVVM 框架，数据驱动视图</li><li>都使用虚拟 DOM</li></ol><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><p><strong>模版 vs JSX</strong></p><p>Vue 是模版语法，react 推崇 <strong>all in js</strong> 所以独创了 JSX 语法，但他们本质都是语法糖，编译后都是一个可执行函数。</p><p><strong>声明式编程 vs 函数式编程</strong></p><p>React 中的值始终是不可变的，所以如果想改变数据，必须调用 api，Vue 使用声明式编程，可以直接赋值。</p><p><strong>数据流</strong></p><p>都为单向数据流，但是 Vue 可以通过 <code>v-model</code> 语法糖实现双向绑定 <br></p><p>Vue 是双向数据绑定的 MVVM 框架，采用数据劫持 + 发布-订阅的模式，View 修改可以让 Model 发生改变，而 Model 的变化也会更新 View</p><p><strong>diff 算法</strong></p><p>TODO</p><h2 id="为什么-data-是一个函数" tabindex="-1">为什么 data 是一个函数 <a class="header-anchor" href="#为什么-data-是一个函数" aria-label="Permalink to &quot;为什么 data 是一个函数&quot;">​</a></h2><p>Vue 中的组件是可以复用的，数据以函数返回这样每次复用都会创建一个新的空间，使实例维护自己的数据，不会被其他干扰。</p><h2 id="vue-渲染流程" tabindex="-1">Vue 渲染流程 <a class="header-anchor" href="#vue-渲染流程" aria-label="Permalink to &quot;Vue 渲染流程&quot;">​</a></h2><ol><li>模版编译：将模版生产抽象语法树（AST），并将 AST 转换成 render 函数</li><li>调用 render 函数生成 虚拟 DOM（vnode）</li><li>调用 patch 函数，通过 createElement 递归的将虚拟 DOM 转换成真实 DOM</li></ol><h2 id="vue2-vue3-对比" tabindex="-1">Vue2 Vue3 对比 <a class="header-anchor" href="#vue2-vue3-对比" aria-label="Permalink to &quot;Vue2 Vue3 对比&quot;">​</a></h2><h4 id="设计思想" tabindex="-1">设计思想 <a class="header-anchor" href="#设计思想" aria-label="Permalink to &quot;设计思想&quot;">​</a></h4><ol><li>Vue3 将所有模块独立出来，比如可以单独使用响应式模块，并不需要引入整个 Vue</li><li>vue2 中存在 <code>Vue.$nextTick Vue.component</code> 等挂载到原形的方法，不利于 tree-shaking，Vue3 将这些 api 重写</li><li>扩展更方便：Vue3 允许自定义渲染器，扩展能力强。不会发生以前的事情，改写 Vue 源码改造渲染方式。</li></ol><h4 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h4><p>vue3 提出了 setup</p><h4 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h4><p>proxy 替代了 Object.defineProperty <a href="./../js/proxy.html#proxy-和-objectdefineproperty-的区别">proxy 和 Object.defineProperty 的区别</a></p><h4 id="diff-算法-vue3-相比-vue2-的优点" tabindex="-1">diff 算法 <a href="./diff.html#vue3-相比-vue2-的优点">vue3 相比 vue2 的优点</a> <a class="header-anchor" href="#diff-算法-vue3-相比-vue2-的优点" aria-label="Permalink to &quot;diff 算法 [vue3 相比 vue2 的优点](./diff.md#vue3-相比-vue2-的优点)&quot;">​</a></h4><br><h4 id="api-风格" tabindex="-1">API 风格 <a class="header-anchor" href="#api-风格" aria-label="Permalink to &quot;API 风格&quot;">​</a></h4><ul><li><p>vue2 中使用的是 <strong>选项式 （Options API）</strong>，其特点是代码写在一起，通过 this 访问，所以出现了一些问题</p><ol><li>随着业务逻辑变得复杂，代码会很大（一个文件特别多逻辑）</li><li>需要考虑 this 指向的问题</li><li>因为都是挂载到组件实例上，一些未使用的方法和属性依旧会被打包</li><li>组件逻辑共享只能通过 mixin 实现，但是会有数据来源不明确的问题</li></ol></li><li><p>vue3 使用的是 <strong>组合式（Composition API）</strong>, 能够将业务代码按照功能拆分成独立的块更好的维护和复用，同时对 tree-shaking 也更加友好</p></li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6879300070962003982" target="_blank" rel="noreferrer">掘金：Vue 的 MVVM 思想(包含三个常见面试题)</a></li></ul>',37),l=[r];function n(d,u,h,s,c,p){return a(),i("div",null,l)}const b=e(t,[["render",n]]);export{f as __pageData,b as default};
