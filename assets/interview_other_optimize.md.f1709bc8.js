import{_ as a,o as e,c as l,Q as s}from"./chunks/framework.f14b72c3.js";const y=JSON.parse('{"title":"前端页面优化","description":"","frontmatter":{},"headers":[],"relativePath":"interview/other/optimize.md"}'),n={name:"interview/other/optimize.md"},o=s(`<h1 id="前端页面优化" tabindex="-1">前端页面优化 <a class="header-anchor" href="#前端页面优化" aria-label="Permalink to &quot;前端页面优化&quot;">​</a></h1><h2 id="代码层" tabindex="-1">代码层 <a class="header-anchor" href="#代码层" aria-label="Permalink to &quot;代码层&quot;">​</a></h2><h3 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-label="Permalink to &quot;HTML&quot;">​</a></h3><ul><li><a href="./../../knowledge/browser/render.html#defer-async">css 放在文件头，js 放在文件尾部，适当的使用异步下载</a></li><li><a href="./../../knowledge/browser/preload.html">prefetch preload preconnect dns-prefetch</a></li></ul><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ul><li>避免使用复杂的选择器，推荐 <a href="./../../knowledge/css/bem.html">bem</a></li></ul><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/* bad */</span></span>
<span class="line"><span style="color:#E06C75;">body</span><span style="color:#C678DD;"> </span><span style="color:#ABB2BF;">&gt;</span><span style="color:#C678DD;"> </span><span style="color:#E06C75;">main</span><span style="color:#D19A66;">.container</span><span style="color:#C678DD;"> </span><span style="color:#ABB2BF;">&gt;</span><span style="color:#C678DD;"> </span><span style="color:#E06C75;">aside</span><span style="color:#D19A66;">.aside</span><span style="color:#C678DD;"> </span><span style="color:#E06C75;">div</span><span style="color:#56B6C2;">:nth-of-type</span><span style="color:#C678DD;">(odd)</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre></div><ul><li>使用 sass、less 等预处理工具时 避免嵌套过深，会导致选择器复杂</li><li>使用 flex 布局替代 float 布局</li><li>提取公共样式，避免重复书写</li></ul><h3 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h3><ul><li>减少<a href="./../../knowledge/browser/repaint_reflow.html#3-性能优化---减少回流重绘次数">重排重绘</a></li><li>使用<a href="./../../knowledge/js/event.html#事件委托">事件委托</a></li><li>使用 <code>Map</code> 映射的方式来取代 多个 <code>if else</code> 和 <code>switch</code></li><li>使用 <code>requestAnimationFrame</code> 替代 <code>setTimeout</code> 和 <code>setInterval</code></li><li>使用 webWorker 来处理复杂的运算</li><li>响应式图片加载：不同分辨率的设备使用不同尺寸的图片，适合手机端</li><li>公共组件提取 减少重复逻辑</li><li>图片懒加载 （使用 intersectionObserver 替代 监听滚动）</li></ul><h4 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h4><ul><li>函数式组件：一个不包含状态和实例的组件，减少响应式带来的性能消耗</li><li>无需响应式的变量无需挂载到 data 上</li><li>不需要响应式的 用 <code>Object.freeze</code> 来冻结一些大对象</li><li>v-if v-show 合理使用</li><li>避免 v-if v-for 同时使用，应使用计算属性</li><li>巧用 KeepAlive 动态组件缓存 DOM，避免不必要的性能浪费</li><li>合理使用 v-for 中的 key，不推荐 index</li><li>组件懒加载、异步组件</li></ul><h2 id="编译层" tabindex="-1">编译层 <a class="header-anchor" href="#编译层" aria-label="Permalink to &quot;编译层&quot;">​</a></h2><ul><li>压缩 js、css、图片体积，整体 gzip</li><li>小尺寸图片转成 base64 格式 减少网络请求</li><li>借助 <code>webpack-bundle-analyzer</code> 包分析包体积，并找出可优化的地方</li><li>借助 <code>@babel/plugin-transform-runtime</code> 将 ES6 -&gt; ES5 的辅助代码整合到一起，而不是每个包都创建一个</li><li>tree-shaking</li><li>按需引入，路由懒加载</li></ul><h2 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h2><ul><li>多个小文件合并成一个</li><li>使用 <a href="./../../knowledge/network/http.html#http2-的改进">HTTP2</a></li><li>静态资源使用 CDN, 能够分担主服务器的压力，并且能够找到延时、负载相对最优的服务器，提升速度。</li><li>合理使用<a href="./../../knowledge/browser/cache.html">浏览器缓存</a></li></ul><h2 id="体验优化" tabindex="-1">体验优化 <a class="header-anchor" href="#体验优化" aria-label="Permalink to &quot;体验优化&quot;">​</a></h2><ul><li>加载页面 （骨骼屏）</li></ul><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><ul><li>使用字体图标代替图片</li><li>压缩图片体积，大背景图用 jpg，图标用 png</li><li>使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftinypng.com%2F" target="_blank" rel="noreferrer">TinyPng</a>压缩图片</li></ul><h2 id="开发体验" tabindex="-1">开发体验 <a class="header-anchor" href="#开发体验" aria-label="Permalink to &quot;开发体验&quot;">​</a></h2><h4 id="webpack-缓存" tabindex="-1">webpack 缓存 <a class="header-anchor" href="#webpack-缓存" aria-label="Permalink to &quot;webpack 缓存&quot;">​</a></h4><ul><li>对一些三方库，稳定不变的缓存</li><li>通过配置 webpack 持久化缓存 cache: filesystem，来缓存生成的 webpack 模块和 chunk，改善构建速度。</li><li>对 loader 指定 include 和 exclude</li></ul><h4 id="webpack-resolve-配置" tabindex="-1">webpack resolve 配置 <a class="header-anchor" href="#webpack-resolve-配置" aria-label="Permalink to &quot;webpack resolve 配置&quot;">​</a></h4><p>alias: 可以创建 import 或 require 的别名，用来简化模块引入。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">module</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">exports</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">resolve</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">alias</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#98C379;">&#39;@&#39;</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">paths</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">src</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// @ 代表 src 路径</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span></code></pre></div><p>extensions: 给文件增加默认扩展名</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">module</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">exports</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">resolve</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">extensions</span><span style="color:#ABB2BF;">: [</span><span style="color:#98C379;">&#39;.vue&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;.js&#39;</span><span style="color:#ABB2BF;">] </span><span style="color:#7F848E;font-style:italic;">// 由于 webpack 的解析顺序是从左到右，因此要将使用频率高的文件类型放在左侧</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span></code></pre></div><h4 id="借助-thread-loader-实现多线程打包" tabindex="-1">借助 thread-loader 实现多线程打包 <a class="header-anchor" href="#借助-thread-loader-实现多线程打包" aria-label="Permalink to &quot;借助 thread-loader 实现多线程打包&quot;">​</a></h4><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://www.cnblogs.com/o2team/p/15220107.html" target="_blank" rel="noreferrer">博客园：学习 Webpack5 之路（优化篇）</a></li><li><a href="https://juejin.cn/post/7014839145537208333" target="_blank" rel="noreferrer">掘金：前端性能优化之代码分割，bundle 包减少了 26%</a></li></ul>`,31),r=[o];function t(i,p,c,d,h,B){return e(),l("div",null,r)}const b=a(n,[["render",t]]);export{y as __pageData,b as default};
