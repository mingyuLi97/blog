import{_ as l,o,c as e,R as a}from"./chunks/framework.35669211.js";const b=JSON.parse('{"title":"rollup","description":"","frontmatter":{},"headers":[],"relativePath":"engineer/rollup/index.md"}'),r={name:"engineer/rollup/index.md"},i=a('<h1 id="rollup" tabindex="-1">rollup <a class="header-anchor" href="#rollup" aria-label="Permalink to &quot;rollup&quot;">​</a></h1><h2 id="构建阶段" tabindex="-1">构建阶段 <a class="header-anchor" href="#构建阶段" aria-label="Permalink to &quot;构建阶段&quot;">​</a></h2><p>Rollup 会先进入到 <strong>Build</strong> 阶段，解析各模块的内容及依赖关系，然后进入 <strong>Output</strong> 阶段</p><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202301071707463.png" alt="" data-__preview__="true"></p><p>经过 <strong>Build</strong> 阶段的 <code>bundle</code> 对象其实并没有进行模块的打包，这个对象的作用在于存储各个模块的内容及依赖关系，同时暴露 <code>generate</code> 和 <code>write</code> 方法，以进入到后续的 <strong>Output</strong> 阶段（<code>write</code> 和 <code>generate</code> 方法唯一的区别在于前者打包完产物会写入磁盘，而后者不会）。</p><h2 id="hook-的类型" tabindex="-1">Hook 的类型 <a class="header-anchor" href="#hook-的类型" aria-label="Permalink to &quot;Hook 的类型&quot;">​</a></h2><h4 id="依据构建阶段分类" tabindex="-1">依据构建阶段分类： <a class="header-anchor" href="#依据构建阶段分类" aria-label="Permalink to &quot;依据构建阶段分类：&quot;">​</a></h4><ul><li><strong>Build Hook</strong></li></ul><p>即在 Build 阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么这个阶段的 Hook 对于代码的操作粒度一般为模块级别，也就是单文件级别。</p><ul><li><strong>Output Hook(Output Generation Hook)</strong></li></ul><p>主要进行代码的打包，对于代码而言，操作粒度一般为 chunk 级别(一个 chunk 通常指很多文件打包到一起的产物)。</p><h4 id="依据执行方式分类" tabindex="-1">依据执行方式分类 <a class="header-anchor" href="#依据执行方式分类" aria-label="Permalink to &quot;依据执行方式分类&quot;">​</a></h4><ul><li><strong>Async &amp; Sync</strong></li></ul><p>首先是 Async 和 Sync 钩子函数，两者其实是相对的，分别代表异步和同步的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。</p><ul><li><strong>Parallel</strong></li></ul><p>并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成(底层使用 Promise.all)。</p><ul><li><strong>Sequential</strong></li></ul><p>串行钩子函数，适用于插件间处理结果相互依赖的情况，即前一个插件 Hook 的返回值作为后续插件的入参。</p><ul><li><strong>First</strong></li></ul><p>如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。比较典型的 Hook 是 resolveId，一旦有插件的 resolveId 返回了一个路径，将停止执行后续插件的 resolveId 逻辑。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Async/Sync 可以搭配后面三种类型中的任意一种，比如一个 Hook 既可以是 Async 也可以是 First 类型</p></div><h2 id="rollup-为什么更适合打包类库" tabindex="-1">Rollup 为什么更适合打包类库 <a class="header-anchor" href="#rollup-为什么更适合打包类库" aria-label="Permalink to &quot;Rollup 为什么更适合打包类库&quot;">​</a></h2><ol><li>rollup 打包出来的体积比 webpack 小。</li><li>通过查看打包出来的代码，webpack 打包出来的文件里面有很多 <code>webpack_require</code> 工具函数的定义，可读性很差，而 rollup 打包出来的 js 会简单一点。</li></ol><h2 id="plugins" tabindex="-1">Plugins <a class="header-anchor" href="#plugins" aria-label="Permalink to &quot;Plugins&quot;">​</a></h2><h4 id="rollup-plugin-node-resolve" tabindex="-1">@rollup/plugin-node-resolve <a class="header-anchor" href="#rollup-plugin-node-resolve" aria-label="Permalink to &quot;@rollup/plugin-node-resolve&quot;">​</a></h4><p>为了允许我们加载第三方依赖，否则像 <code>import React from &#39;react&#39;</code> 的依赖导入语句将不会被 Rollup 识别。</p><h4 id="rollup-plugin-commonjs" tabindex="-1">@rollup/plugin-commonjs <a class="header-anchor" href="#rollup-plugin-commonjs" aria-label="Permalink to &quot;@rollup/plugin-commonjs&quot;">​</a></h4><p>作用是将 CommonJS 格式的代码转换为 ESM 格式</p><h4 id="rollup-plugin-json" tabindex="-1">@rollup/plugin-json <a class="header-anchor" href="#rollup-plugin-json" aria-label="Permalink to &quot;@rollup/plugin-json&quot;">​</a></h4><p>支持.json 的加载，并配合 rollup 的 Tree Shaking 机制去掉未使用的部分，进行按需打包。</p><h4 id="rollup-plugin-babel" tabindex="-1">@rollup/plugin-babel <a class="header-anchor" href="#rollup-plugin-babel" aria-label="Permalink to &quot;@rollup/plugin-babel&quot;">​</a></h4><p>在 Rollup 中使用 Babel 进行 JS 代码的语法转译。</p><h4 id="rollup-plugin-typescript" tabindex="-1">@rollup/plugin-typescript <a class="header-anchor" href="#rollup-plugin-typescript" aria-label="Permalink to &quot;@rollup/plugin-typescript&quot;">​</a></h4><p>支持使用 TypeScript 开发。</p><h4 id="rollup-plugin-alias" tabindex="-1">@rollup/plugin-alias <a class="header-anchor" href="#rollup-plugin-alias" aria-label="Permalink to &quot;@rollup/plugin-alias&quot;">​</a></h4><p>支持别名配置。</p><h4 id="rollup-plugin-replace" tabindex="-1">@rollup/plugin-replace <a class="header-anchor" href="#rollup-plugin-replace" aria-label="Permalink to &quot;@rollup/plugin-replace&quot;">​</a></h4><p>在 Rollup 进行变量字符串的替换。</p><h4 id="rollup-plugin-visualizer" tabindex="-1">rollup-plugin-visualizer <a class="header-anchor" href="#rollup-plugin-visualizer" aria-label="Permalink to &quot;rollup-plugin-visualizer&quot;">​</a></h4><p>对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。</p><h4 id="rollup-plugin-terser" tabindex="-1">rollup-plugin-terser <a class="header-anchor" href="#rollup-plugin-terser" aria-label="Permalink to &quot;rollup-plugin-terser&quot;">​</a></h4><p>对生成的产物压缩</p>',42),p=[i];function u(n,t,s,c,d,h){return o(),e("div",null,p)}const m=l(r,[["render",u]]);export{b as __pageData,m as default};
