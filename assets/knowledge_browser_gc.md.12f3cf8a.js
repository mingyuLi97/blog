import{_ as a,o as s,c as l,U as n}from"./chunks/framework.3125349e.js";const u=JSON.parse('{"title":"垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/browser/gc.md","filePath":"knowledge/browser/gc.md"}'),o={name:"knowledge/browser/gc.md"},e=n(`<h1 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h1><p>在写代码时，每创建一个对象、函数等都需要开辟一块内存，我们并不关注这些，因为引擎已经做好了。 随着程序的运行，会有很多用不到的内存空间，我们称之为垃圾，这些闲置的内存需要及时清理，否则内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。 当然垃圾清理也是由引擎来完成，我们称之为 <code>GC</code> 即 <code>Garbage Collection</code></p><h2 id="垃圾回收策略" tabindex="-1">垃圾回收策略 <a class="header-anchor" href="#垃圾回收策略" aria-label="Permalink to &quot;垃圾回收策略&quot;">​</a></h2><p>在 JavaScript 内存管理中有一个概念叫做 <strong>可达性</strong>，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收</p><h3 id="引用计数法-reference-counting" tabindex="-1">引用计数法（Reference Counting） <a class="header-anchor" href="#引用计数法-reference-counting" aria-label="Permalink to &quot;引用计数法（Reference Counting）&quot;">​</a></h3><p>为占用物理空间的对象附加一个计数器，每次有其他对象引用计数加一，反之解除引用减一，如果为 0 就将其物理空间收回</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ol><li>及时，引用数到 0 立刻收回垃圾</li><li>不需要遍历堆区</li></ol><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ol><li>无法解决循环引用的问题：</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">test</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">A</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Object</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">B</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Object</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">A</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">B</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">B</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">A</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre></div><ol start="2"><li>需要很多个计数器，浪费空间</li></ol><h3 id="标记清除算法-mark-sweep" tabindex="-1">标记清除算法（Mark-Sweep） <a class="header-anchor" href="#标记清除算法-mark-sweep" aria-label="Permalink to &quot;标记清除算法（Mark-Sweep）&quot;">​</a></h3><p>与计数不同的，该算法的核心变为定期检查是否<strong>可达</strong>。算法逻辑可以简化成这样</p><ol><li>首先假定所有对象都为垃圾</li><li>从根对象开始遍历，能访问的都改为 “非垃圾”</li><li>清除所有标记为垃圾的空间</li></ol><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p>内存碎片化，清理完成后空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</p><p>用 <strong>标记整理（Mark-Compact）算法</strong> 可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</p><h2 id="v8-引擎的策略" tabindex="-1">V8 引擎的策略 <a class="header-anchor" href="#v8-引擎的策略" aria-label="Permalink to &quot;V8 引擎的策略&quot;">​</a></h2><p>V8 引擎基于分代（新生代｜老生代）式垃圾回收机制，对不同的生代采用不同的策略</p><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><p>新生代是存活较短的对象（新创建出来的），容量很小。</p><p><strong>策略</strong>：新生代的内存空间分为使用区和空闲区，新加入的对象会放置到使用区，当使用区满了之后会执行垃圾清理操作，将所有活动的对象进行标记然后拷贝到空闲区，接着把使用区的空间清理掉。最后在进行角色互换，把使用区变成空闲区，空闲区变成使用区。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>为什么使用空闲的区间？答：空间换时间，相比于移动拷贝的时间复杂度更低。</li><li>当一个对象多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代。</li></ol></div><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><p>老生代的对象为存活时间较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p><p><strong>策略</strong>：标记-整理-清除</p><h2 id="减少垃圾" tabindex="-1">减少垃圾 <a class="header-anchor" href="#减少垃圾" aria-label="Permalink to &quot;减少垃圾&quot;">​</a></h2><ol><li>多复用创建出来的对象（<code>Object、Array、Function...</code>），避免重复创建</li><li>清空数组</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// bad 因为会重新创建出一个新的数组</span></span>
<span class="line"><span style="color:#E06C75;">arr</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// good</span></span>
<span class="line"><span style="color:#E5C07B;">arr</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span></code></pre></div><ol start="3"><li>清除不用的定时器</li><li>减少使用全局变量</li><li>避免使用闭包</li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6981588276356317214" target="_blank" rel="noreferrer">掘金：「硬核 JS」你真的了解垃圾回收机制吗</a></li><li><a href="https://zhuanlan.zhihu.com/p/60336501" target="_blank" rel="noreferrer">知乎：JavaScript 垃圾回收机制</a></li></ul>`,33),p=[e];function t(r,c,i,B,h,d){return s(),l("div",null,p)}const A=a(o,[["render",t]]);export{u as __pageData,A as default};
