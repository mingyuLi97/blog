import{_ as t,o as e,c as a,R as l}from"./chunks/framework.d45ee533.js";const _=JSON.parse('{"title":"事件循环 EventLoop","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/browser/event_loop.md"}'),r={name:"knowledge/browser/event_loop.md"},o=l('<h1 id="事件循环-eventloop" tabindex="-1">事件循环 EventLoop <a class="header-anchor" href="#事件循环-eventloop" aria-label="Permalink to &quot;事件循环 EventLoop&quot;">​</a></h1><p><code>Event Loop</code> 即事件循环，是浏览器(或 Node)防止 <strong>js 单线程</strong> 运行时阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p><h2 id="同步任务和异步任务" tabindex="-1">同步任务和异步任务 <a class="header-anchor" href="#同步任务和异步任务" aria-label="Permalink to &quot;同步任务和异步任务&quot;">​</a></h2><p><strong>同步任务：</strong> 同步任务会在调用栈中按照顺序等待主线程依次执行</p><p><strong>异步任务：</strong> 异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p><h2 id="宏任务-macro-task" tabindex="-1">宏任务 macro task <a class="header-anchor" href="#宏任务-macro-task" aria-label="Permalink to &quot;宏任务 macro task&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">-</th><th style="text-align:center;">浏览器</th><th style="text-align:center;">Node</th></tr></thead><tbody><tr><td style="text-align:left;">I/O</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:left;">setTimeout</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:left;">setInterval</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:left;">setImmediate</td><td style="text-align:center;">❌ (仅 IE10 支持)</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:left;">requestAnimationFrame</td><td style="text-align:center;">✅</td><td style="text-align:center;">❌</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>requestAnimationFrame 是一个很特殊的存在，它会在页面渲染前调用。 在每一次 event loop 的末尾，判断当前页面是否处于<strong>渲染时机</strong>(比如硬件限制，60hz 的屏幕每 16.66ms 渲染一次)，如果是就重新渲染。</p></div><h2 id="微任务-micro-task" tabindex="-1">微任务 micro task <a class="header-anchor" href="#微任务-micro-task" aria-label="Permalink to &quot;微任务 micro task&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">-</th><th style="text-align:center;">浏览器</th><th style="text-align:center;">Node</th></tr></thead><tbody><tr><td style="text-align:left;">process.nextTick</td><td style="text-align:center;">❌</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:left;">MutationObserver</td><td style="text-align:center;">✅</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:left;">Promise</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr></tbody></table><h2 id="执行流程" tabindex="-1">执行流程 <a class="header-anchor" href="#执行流程" aria-label="Permalink to &quot;执行流程&quot;">​</a></h2><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202209181703122-event_loop.png" alt="EventLoop" data-__preview__="true"></p><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202209181756737-event_loop.gif" alt="" data-__preview__="true"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ol><li>js 遇到一个异步任务后不会等待其返回结果，而是将其挂起，继续执行执行栈中的同步任务</li><li>当异步返回结果后，不会立即执行，而是将结果添加到<strong>任务队列</strong>中</li><li>当主线程空闲（任务都执行完）时，会查看任务队列中是否有任务，如果有将其取出并放入到执行栈，然后执行其中的同步代码</li><li>如此往复，形成了一个环（事件循环）</li><li>事件循环不一定每轮都伴随着重渲染。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 可以理解为，每一轮事件循环执行一个宏任务，清空所有微任务</p></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6844903764202094606" target="_blank" rel="noreferrer">掘金：一次弄懂 Event Loop（彻底解决此类面试问题）</a></li><li><a href="https://zhuanlan.zhihu.com/p/142742003" target="_blank" rel="noreferrer">知乎：深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系</a></li><li><a href="https://blog.csdn.net/ligang2585116/article/details/98023768" target="_blank" rel="noreferrer">CSDN：Event loop 及 macro task &amp; micro task</a></li></ul>',18),n=[o];function s(i,d,c,h,p,g){return e(),a("div",null,n)}const x=t(r,[["render",s]]);export{_ as __pageData,x as default};
