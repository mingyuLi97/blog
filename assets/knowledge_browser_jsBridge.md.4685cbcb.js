import{_ as a,o as s,c as e,Q as l}from"./chunks/framework.f14b72c3.js";const u=JSON.parse('{"title":"JsBridge","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/browser/jsBridge.md"}'),o={name:"knowledge/browser/jsBridge.md"},n=l(`<h1 id="jsbridge" tabindex="-1">JsBridge <a class="header-anchor" href="#jsbridge" aria-label="Permalink to &quot;JsBridge&quot;">​</a></h1><h2 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h2><p>构建 Native 和 js 之间的消息通道，实现双向通信。</p><h2 id="js-调用-native" tabindex="-1">js 调用 Native <a class="header-anchor" href="#js-调用-native" aria-label="Permalink to &quot;js 调用 Native&quot;">​</a></h2><h2 id="方式一-拦截-url-scheme" tabindex="-1">方式一：拦截 URL_SCHEME <a class="header-anchor" href="#方式一-拦截-url-scheme" aria-label="Permalink to &quot;方式一：拦截 URL_SCHEME&quot;">​</a></h2><p><code>URL Scheme</code> 是类 URL 的一种请求格式：<code>&lt;protocol&gt;://&lt;host&gt;/&lt;path&gt;?&lt;query&gt;#fragment</code></p><p>一般会约定一种协议格式，例：<code>weixin://dl/about</code></p><h5 id="客户端拦截-web-发起的请求" tabindex="-1">客户端拦截 web 发起的请求： <a class="header-anchor" href="#客户端拦截-web-发起的请求" aria-label="Permalink to &quot;客户端拦截 web 发起的请求：&quot;">​</a></h5><ul><li>如果符合我们自定义的 URL Schema，对 URL 进行解析，拿到相关操作、操作，进而调用原生 Native 的方法</li><li>如果不符合我们自定义的 URL Schema，我们直接转发，请求真正的服务</li></ul><h5 id="web-发送-url-请求的方法" tabindex="-1">Web 发送 URL 请求的方法： <a class="header-anchor" href="#web-发送-url-请求的方法" aria-label="Permalink to &quot;Web 发送 URL 请求的方法：&quot;">​</a></h5><ul><li><code>使用 iframe.src (常用)</code></li><li>a 标签 (需要用户操作)</li><li>location.href (能会引起页面的跳转丢失调用)</li><li>发送 ajax 请求 (Android 没有相应的拦截方法)</li></ul><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ol><li>浏览器的 url 有长度限制，如果信息过长会造成截断。</li><li>修改 <code>iframe.src</code> 会有一定的性能损耗，不如注入式的性能好</li></ol><h2 id="方式二-注入-api" tabindex="-1">方式二：注入 API <a class="header-anchor" href="#方式二-注入-api" aria-label="Permalink to &quot;方式二：注入 API&quot;">​</a></h2><p>这个方法会通过 webView 提供的接口，App 将 Native 的相关接口注入到 JS 的 Context（window）的对象中，一般来说这个对象内的方法名与 Native 相关方法名是相同的，Web 端就可以直接在全局 window 下使用这个暴露的全局 JS 对象，进而调用原生端的方法。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">window</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">WeixinJSBridge</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">showDialog</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;hello&#39;</span><span style="color:#ABB2BF;">);</span></span></code></pre></div><h5 id="实现回调" tabindex="-1">实现回调 <a class="header-anchor" href="#实现回调" aria-label="Permalink to &quot;实现回调&quot;">​</a></h5><p>通过两次单项通信实现：一端调用的时候在参数中加一个 callbackId 标记对应的回调，对端接收到调用请求后，进行实际操作，如果带有 callbackId，对端再进行一次调用，将结果、callbackId 回传回来，这端根据 callbackId 匹配相应的回调，将结果传入执行就可以了。</p><h2 id="native-调用-js" tabindex="-1">Native 调用 js <a class="header-anchor" href="#native-调用-js" aria-label="Permalink to &quot;Native 调用 js&quot;">​</a></h2><p>js 是解释型语言，其特点就是能随时随地执行一段 js 代码 。 Android 4.4 之前只能用 <code>loadUrl</code> 来实现，并且无法执行回调：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">String</span><span style="color:#E06C75;"> jsCode </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">format</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;window.showWebDialog(&#39;%s&#39;)&quot;</span><span style="color:#ABB2BF;">, text);</span></span>
<span class="line"><span style="color:#E5C07B;">webView</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">loadUrl</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;javascript: &quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> jsCode);</span></span></code></pre></div><p>Android 4.4 之后提供了 <code>evaluateJavascript</code> 来执行 JS 代码，并且可以获取返回值执行回调：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">String</span><span style="color:#E06C75;"> jsCode </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">format</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;window.showWebDialog(&#39;%s&#39;)&quot;</span><span style="color:#ABB2BF;">, text);</span></span>
<span class="line"><span style="color:#E5C07B;">webView</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">evaluateJavascript</span><span style="color:#ABB2BF;">(jsCode, </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">ValueCallback</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">&gt;() {</span></span>
<span class="line"><span style="color:#ABB2BF;">@</span><span style="color:#E5C07B;">Override</span></span>
<span class="line"><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> </span><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> onReceiveValue</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">value</span><span style="color:#ABB2BF;">)</span><span style="color:#61AFEF;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span></code></pre></div><p>iOS 的 UIWebView 使用 <code>stringByEvaluatingJavaScriptFromString：</code></p><div class="language-objective-c"><button title="Copy Code" class="copy"></button><span class="lang">objective-c</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">NSString</span><span style="color:#ABB2BF;"> _jsStr </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">@&quot;执行的 JS 代码&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">[webView </span><span style="color:#61AFEF;">stringByEvaluatingJavaScriptFromString:</span><span style="color:#ABB2BF;">jsStr];</span></span></code></pre></div><p>iOS 的 WKWebView 使用 <code>evaluateJavaScript：</code></p><div class="language-objective-c"><button title="Copy Code" class="copy"></button><span class="lang">objective-c</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#ABB2BF;">[webView </span><span style="color:#61AFEF;">evaluateJavaScript:</span><span style="color:#98C379;">@&quot;执行的 JS 代码&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">completionHandler:</span><span style="color:#ABB2BF;">^(</span><span style="color:#C678DD;">id</span><span style="color:#ABB2BF;"> \\_Nullable response, </span><span style="color:#E5C07B;">NSError</span><span style="color:#ABB2BF;"> \\_ \\_Nullable error) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}];</span></span></code></pre></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6936814903021797389" target="_blank" rel="noreferrer">掘金：深入浅出 JSBridge：从原理到使用</a></li></ul>`,29),p=[n];function t(r,c,i,B,d,y){return s(),e("div",null,p)}const b=a(o,[["render",t]]);export{u as __pageData,b as default};
