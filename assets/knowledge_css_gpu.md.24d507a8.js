import{_ as e,o as a,c as r,R as t}from"./chunks/framework.d45ee533.js";const f=JSON.parse('{"title":"CSS3 硬件加速(GPU 加速)","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/css/gpu.md"}'),o={name:"knowledge/css/gpu.md"},i=t('<h1 id="css3-硬件加速-gpu-加速" tabindex="-1">CSS3 硬件加速(GPU 加速) <a class="header-anchor" href="#css3-硬件加速-gpu-加速" aria-label="Permalink to &quot;CSS3 硬件加速(GPU 加速)&quot;">​</a></h1><p>CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。</p><p><img src="https://limy-1309594960.cos.ap-beijing.myqcloud.com/202304212219562.png" alt="" data-__preview__="true"></p><h2 id="dom-tree" tabindex="-1">DOM Tree <a class="header-anchor" href="#dom-tree" aria-label="Permalink to &quot;DOM Tree&quot;">​</a></h2><p>DOM 是抽象的文档对象模型，它可以将文档中的元素都看作一个对象，并且可以通过 js 控制。 DOM Tree 是由一系列 DOM 元素构成，每个 DOM 都代表文档中的一个节点。</p><h2 id="renderobject" tabindex="-1">RenderObject <a class="header-anchor" href="#renderobject" aria-label="Permalink to &quot;RenderObject&quot;">​</a></h2><p>RenderObject 是根据 DOM 树、CSS 树和其他信息共同生成的渲染树中的节点，用于表示网页中的可渲染对象。</p><h2 id="renderlayer" tabindex="-1">RenderLayer <a class="header-anchor" href="#renderlayer" aria-label="Permalink to &quot;RenderLayer&quot;">​</a></h2><ul><li>RenderLayer 主要是为了解决层叠上下文、透明元素的问题。</li><li>每个 RenderObject 都直接或通过祖先 RenderObject 间接与 RenderLayer 相关联。</li><li>RenderLayer 可以理解为一个渲染图层，渲染就是将一个个 RenderObject 绘制到这个图层。这个过程可以使用 CPU 绘制，<strong>这就是软件绘图</strong>。但是软件绘图是无法处理 3D 的绘图上下文，每一层的 RenderObject 中都不能包含使用 3D 绘图的节点，例如有 3D Context 的 Canvas 节点，也不能支持 CSS 3D 变化属性。此外，页面动画中，每次元素尺寸或者位置变动，都要重新去构造 RenderLayer 树，触发 Layout 及其后续的渲染流水线。这样会导致页面帧率的下降，造成视觉上的卡顿。所以现代浏览器引入了由 GPU 完成的<strong>硬件加速绘图</strong>。</li></ul><h2 id="graphics-layer-compositing-layer-合成层" tabindex="-1">Graphics Layer（Compositing Layer）- 合成层 <a class="header-anchor" href="#graphics-layer-compositing-layer-合成层" aria-label="Permalink to &quot;Graphics Layer（Compositing Layer）- 合成层&quot;">​</a></h2><p>如果每一个 RenderLayer 都交由 GPU 渲染，那么会浪费内存资源，为了解决这个问题 Webkit 将一些 RenderLayer 组合在一起形成一个新层（合成层）</p><h4 id="如何触发硬件加速" tabindex="-1">如何触发硬件加速 <a class="header-anchor" href="#如何触发硬件加速" aria-label="Permalink to &quot;如何触发硬件加速&quot;">​</a></h4><p>一些 CSS 属性</p><ul><li>3D transform</li><li>backface-visibility 为 hidden</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition <ul><li>📝 需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效</li></ul></li><li>will-change 设置为 opacity、transform、top、left、bottom、right <ul><li>📝 其中 top、left 等需要设置明确的定位属性，如 relative 等</li></ul></li></ul><p><a href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite/" target="_blank" rel="noreferrer">合成层条件（全）</a></p><h4 id="提升为合成层好处" tabindex="-1">提升为合成层好处 <a class="header-anchor" href="#提升为合成层好处" aria-label="Permalink to &quot;提升为合成层好处&quot;">​</a></h4><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://segmentfault.com/a/1190000041295744" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000041295744</a></li><li><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/" target="_blank" rel="noreferrer">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/</a></li><li><a href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite/" target="_blank" rel="noreferrer">https://fed.taobao.org/blog/taofed/do71ct/performance-composite/</a></li></ul>',19),l=[i];function n(s,c,d,p,h,m){return a(),r("div",null,l)}const g=e(o,[["render",n]]);export{f as __pageData,g as default};
