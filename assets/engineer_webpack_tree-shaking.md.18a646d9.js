import{_ as e,o as a,c as t,Q as o}from"./chunks/framework.f14b72c3.js";const u=JSON.parse('{"title":"Tree Shaking","description":"","frontmatter":{},"headers":[],"relativePath":"engineer/webpack/tree-shaking.md"}'),r={name:"engineer/webpack/tree-shaking.md"},c=o('<h1 id="tree-shaking" tabindex="-1">Tree Shaking <a class="header-anchor" href="#tree-shaking" aria-label="Permalink to &quot;Tree Shaking&quot;">​</a></h1><p>Tree Shanking 依赖于 ES6 import 和 export 静态分析能力，可以在编译阶段将 不会被执行，执行的结果不会被用到，代码只会影响死变量（只写不读）的代码移除。</p><h2 id="失效" tabindex="-1">失效 <a class="header-anchor" href="#失效" aria-label="Permalink to &quot;失效&quot;">​</a></h2><h4 id="export-default" tabindex="-1"><code>export default</code> <a class="header-anchor" href="#export-default" aria-label="Permalink to &quot;`export default`&quot;">​</a></h4><p><code>export default</code> 打包后会作为一个对象整体。Webpack 会分析顶层对象的使用情况，并不会分析对象中的属性，所以 <code>export default</code> 要么就是整体引入，要么就是整体删除。</p><h4 id="函数存在副作用" tabindex="-1">函数存在副作用 <a class="header-anchor" href="#函数存在副作用" aria-label="Permalink to &quot;函数存在副作用&quot;">​</a></h4><blockquote><p>副作用，当我们调用某个函数时，该函数除了返回值之外，还产生附加的影响，例如修改全局变量，函数外的变量或修改参数等，称为存在副作用。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>/*#__PURE__*/</code> 可以标记后面的函数不会产生副作用，这样就能被 TreeShaking</p></div>',8),i=[c];function n(d,s,l,h,p,_){return a(),t("div",null,i)}const f=e(r,[["render",n]]);export{u as __pageData,f as default};
