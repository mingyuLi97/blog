# 第八章：挂载与更新

<script setup>
import RenderVue from './render.vue'
</script>

<ClientOnly>
  <RenderVue/>
</ClientOnly>

## 挂载子节点和元素的属性

1. 遍历 vnode 上的 props 完成属性的挂载
2. 递归的处理 children，完成子节点的挂载

```javascript
const vnode = {
  type: 'div',
  props: {
    id: 'foo'
  },
  children: [
    {
      type: 'p',
      children: 'hello'
    }
  ]
};

function mountElement(vnode, container) {
  const el = document.createElement(vnode.type);

  if (vnode.props) {
    for (const k in vnode.props) {
      // 👇 等同 => el.setAttribute(k, vnode.props[k])
      el[k] = vnode.props[k];
    }
  }

  if (typeof vnode.children === 'string') {
    el.textContent = vnode.children;
  } else if (Array.isArray(vnode.children)) {
    vnode.children.forEach(child => {
      // 因为是第一次挂载，旧节点仍然传递 null。 挂载的元素是新创建出来的 el
      patch(null, child, el);
    });
  }

  container.appendChild(el);
}
```

## HTML Attributes 和 DOM Properties

HTML Attributes： `<div id='foo'>`

DOM Properties：

```javascript
const el = document.querySelector('#foo');
el.id = 'xxx';
```

:::tip
HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值。因此后面设置值时应优先使用 DOM Properties。
:::

```javascript
// 一个 input 标签 <input value="foo" />
const el = document.querySelector('input');
el.value; // foo
el.getAttribute('value'); // foo
// -------- 将 value 修改为 bar -------------
el.value; // bar
el.getAttribute('value'); // foo
el.defaultValue; // foo
```

## 一些特殊处理

我们写两个禁用按钮的 dom

```HTML
<button disable> buttonA </button>
<button :disable="false"> buttonB </button>
```

在 vue 模版编译后输出的 vnode

```javascript
const buttonA = {
  type: 'button',
  props: { disable: '' }
};

const buttonB = {
  type: 'button',
  props: { disable: false }
};
```

render 时

```javascript
//  -------------- 执行标签设置 ---------------
el.setAttribute('disable', ''); // 正常
// 设置属性时，总是会被 stringify，在 dom 处理时，再把 'false' => true，这样造成了错误
el.setAttribute('disable', 'false');

//  -------------- 执行属性设置 ---------------
el.disable = ''; // '' => false，引起错误
el.disable = false; // 正常
```

可以发现，无论使用哪种方式都有可能出现问题，对于这种情况只能做特殊处理。

```javascript{10,11}
function mountElement(vnode, container) {
  const el = document.createElement(vnode.type);
  if (vnode.props) {
    for (const k in vnode.props) {
      // 属性是否存在于 DOM Properties
      if (k in el) {
        // 取出数据类型方便后面特殊处理
        const type = typeof el[k];
        const value = vnode.props[k];
        // 特殊处理（button 的 disable）
        if (type === 'boolean' && value === '') {
          el[k] = true;
        } else {
          el[k] = value;
        }
      } else {
        el.setAttribute(k, vnode.props[k]);
      }
    }
  }
  /** ... */
}
```

有一些属性是只读的，不能对其修改，也需要特殊处理。

```html
<form id="form1"></form>
<input form="form1" />
```

```javascript
function shouldSetAsProps(el, key, val) {
  // 特殊处理
  if (key === 'form' && el.tagName === 'INPUT') return false;
  // 兜底
  return key in el;
}

function mountElement(vnode, container) {
  const el = document.createElement(vnode.type);
  if (vnode.props) {
    for (const k in vnode.props) {
      // 属性是否存在于 DOM Properties
      if (shouldSetAsProps(el, k, vnode.props[k])) {
        /** ... */
      } else {
        el.setAttribute(k, vnode.props[k]);
      }
    }
  }
  /** ... */
}
```

## class、style 的特殊处理（增强）

为了方便开发，在 Vue 中使用 class、style 可以使用多种方式

```html
<!-- 字符串 -->
<div class="foo bar"></div>
<!-- 对象 -->
<div :class="{foo: true}"></div>
<!-- 数组 -->
<div :class="[{foo: true}, 'bar']"></div>
```

```javascript
const vnode = {
  type: 'div',
  props: {
    class: normalizeClass([{ foo: true }, 'bar']) // 序列化的结果 => 'foo bar'
  }
};
```

class 有多种设置方式，在设置 1000 次时的性能： `el.className` > `el.setAttribute` > `classList`, 因此 Vue 中使用了 className 的方式
